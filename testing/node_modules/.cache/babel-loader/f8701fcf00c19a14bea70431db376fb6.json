{"ast":null,"code":"/*\r\nAuthor: Geraint Luff and others\r\nYear: 2013\r\n\r\nThis code is released into the \"public domain\" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.\r\n\r\nIf you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.\r\n*/\n(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    // CommonJS. Define export.\n    module.exports = factory();\n  } else {\n    // Browser globals\n    global.tv4 = factory();\n  }\n})(this, function () {\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys\n  if (!Object.keys) {\n    Object.keys = function () {\n      var hasOwnProperty = Object.prototype.hasOwnProperty,\n          hasDontEnumBug = !{\n        toString: null\n      }.propertyIsEnumerable('toString'),\n          dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],\n          dontEnumsLength = dontEnums.length;\n      return function (obj) {\n        if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {\n          throw new TypeError('Object.keys called on non-object');\n        }\n\n        var result = [];\n\n        for (var prop in obj) {\n          if (hasOwnProperty.call(obj, prop)) {\n            result.push(prop);\n          }\n        }\n\n        if (hasDontEnumBug) {\n          for (var i = 0; i < dontEnumsLength; i++) {\n            if (hasOwnProperty.call(obj, dontEnums[i])) {\n              result.push(dontEnums[i]);\n            }\n          }\n        }\n\n        return result;\n      };\n    }();\n  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n\n\n  if (!Object.create) {\n    Object.create = function () {\n      function F() {}\n\n      return function (o) {\n        if (arguments.length !== 1) {\n          throw new Error('Object.create implementation only accepts one parameter.');\n        }\n\n        F.prototype = o;\n        return new F();\n      };\n    }();\n  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray\n\n\n  if (!Array.isArray) {\n    Array.isArray = function (vArg) {\n      return Object.prototype.toString.call(vArg) === \"[object Array]\";\n    };\n  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf\n\n\n  if (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement\n    /*, fromIndex */\n    ) {\n      if (this === null) {\n        throw new TypeError();\n      }\n\n      var t = Object(this);\n      var len = t.length >>> 0;\n\n      if (len === 0) {\n        return -1;\n      }\n\n      var n = 0;\n\n      if (arguments.length > 1) {\n        n = Number(arguments[1]);\n\n        if (n !== n) {\n          // shortcut for verifying if it's NaN\n          n = 0;\n        } else if (n !== 0 && n !== Infinity && n !== -Infinity) {\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\n        }\n      }\n\n      if (n >= len) {\n        return -1;\n      }\n\n      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n\n      for (; k < len; k++) {\n        if (k in t && t[k] === searchElement) {\n          return k;\n        }\n      }\n\n      return -1;\n    };\n  } // Grungey Object.isFrozen hack\n\n\n  if (!Object.isFrozen) {\n    Object.isFrozen = function (obj) {\n      var key = \"tv4_test_frozen_key\";\n\n      while (obj.hasOwnProperty(key)) {\n        key += Math.random();\n      }\n\n      try {\n        obj[key] = true;\n        delete obj[key];\n        return false;\n      } catch (e) {\n        return true;\n      }\n    };\n  } // Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed\n\n\n  var uriTemplateGlobalModifiers = {\n    \"+\": true,\n    \"#\": true,\n    \".\": true,\n    \"/\": true,\n    \";\": true,\n    \"?\": true,\n    \"&\": true\n  };\n  var uriTemplateSuffices = {\n    \"*\": true\n  };\n\n  function notReallyPercentEncode(string) {\n    return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {\n      return \"%\" + doubleEncoded.substring(3);\n    });\n  }\n\n  function uriTemplateSubstitution(spec) {\n    var modifier = \"\";\n\n    if (uriTemplateGlobalModifiers[spec.charAt(0)]) {\n      modifier = spec.charAt(0);\n      spec = spec.substring(1);\n    }\n\n    var separator = \"\";\n    var prefix = \"\";\n    var shouldEscape = true;\n    var showVariables = false;\n    var trimEmptyString = false;\n\n    if (modifier === '+') {\n      shouldEscape = false;\n    } else if (modifier === \".\") {\n      prefix = \".\";\n      separator = \".\";\n    } else if (modifier === \"/\") {\n      prefix = \"/\";\n      separator = \"/\";\n    } else if (modifier === '#') {\n      prefix = \"#\";\n      shouldEscape = false;\n    } else if (modifier === ';') {\n      prefix = \";\";\n      separator = \";\";\n      showVariables = true;\n      trimEmptyString = true;\n    } else if (modifier === '?') {\n      prefix = \"?\";\n      separator = \"&\";\n      showVariables = true;\n    } else if (modifier === '&') {\n      prefix = \"&\";\n      separator = \"&\";\n      showVariables = true;\n    }\n\n    var varNames = [];\n    var varList = spec.split(\",\");\n    var varSpecs = [];\n    var varSpecMap = {};\n\n    for (var i = 0; i < varList.length; i++) {\n      var varName = varList[i];\n      var truncate = null;\n\n      if (varName.indexOf(\":\") !== -1) {\n        var parts = varName.split(\":\");\n        varName = parts[0];\n        truncate = parseInt(parts[1], 10);\n      }\n\n      var suffices = {};\n\n      while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {\n        suffices[varName.charAt(varName.length - 1)] = true;\n        varName = varName.substring(0, varName.length - 1);\n      }\n\n      var varSpec = {\n        truncate: truncate,\n        name: varName,\n        suffices: suffices\n      };\n      varSpecs.push(varSpec);\n      varSpecMap[varName] = varSpec;\n      varNames.push(varName);\n    }\n\n    var subFunction = function subFunction(valueFunction) {\n      var result = \"\";\n      var startIndex = 0;\n\n      for (var i = 0; i < varSpecs.length; i++) {\n        var varSpec = varSpecs[i];\n        var value = valueFunction(varSpec.name);\n\n        if (value === null || value === undefined || Array.isArray(value) && value.length === 0 || typeof value === 'object' && Object.keys(value).length === 0) {\n          startIndex++;\n          continue;\n        }\n\n        if (i === startIndex) {\n          result += prefix;\n        } else {\n          result += separator || \",\";\n        }\n\n        if (Array.isArray(value)) {\n          if (showVariables) {\n            result += varSpec.name + \"=\";\n          }\n\n          for (var j = 0; j < value.length; j++) {\n            if (j > 0) {\n              result += varSpec.suffices['*'] ? separator || \",\" : \",\";\n\n              if (varSpec.suffices['*'] && showVariables) {\n                result += varSpec.name + \"=\";\n              }\n            }\n\n            result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[j]);\n          }\n        } else if (typeof value === \"object\") {\n          if (showVariables && !varSpec.suffices['*']) {\n            result += varSpec.name + \"=\";\n          }\n\n          var first = true;\n\n          for (var key in value) {\n            if (!first) {\n              result += varSpec.suffices['*'] ? separator || \",\" : \",\";\n            }\n\n            first = false;\n            result += shouldEscape ? encodeURIComponent(key).replace(/!/g, \"%21\") : notReallyPercentEncode(key);\n            result += varSpec.suffices['*'] ? '=' : \",\";\n            result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[key]);\n          }\n        } else {\n          if (showVariables) {\n            result += varSpec.name;\n\n            if (!trimEmptyString || value !== \"\") {\n              result += \"=\";\n            }\n          }\n\n          if (varSpec.truncate != null) {\n            value = value.substring(0, varSpec.truncate);\n          }\n\n          result += shouldEscape ? encodeURIComponent(value).replace(/!/g, \"%21\") : notReallyPercentEncode(value);\n        }\n      }\n\n      return result;\n    };\n\n    subFunction.varNames = varNames;\n    return {\n      prefix: prefix,\n      substitution: subFunction\n    };\n  }\n\n  function UriTemplate(template) {\n    if (!(this instanceof UriTemplate)) {\n      return new UriTemplate(template);\n    }\n\n    var parts = template.split(\"{\");\n    var textParts = [parts.shift()];\n    var prefixes = [];\n    var substitutions = [];\n    var varNames = [];\n\n    while (parts.length > 0) {\n      var part = parts.shift();\n      var spec = part.split(\"}\")[0];\n      var remainder = part.substring(spec.length + 1);\n      var funcs = uriTemplateSubstitution(spec);\n      substitutions.push(funcs.substitution);\n      prefixes.push(funcs.prefix);\n      textParts.push(remainder);\n      varNames = varNames.concat(funcs.substitution.varNames);\n    }\n\n    this.fill = function (valueFunction) {\n      var result = textParts[0];\n\n      for (var i = 0; i < substitutions.length; i++) {\n        var substitution = substitutions[i];\n        result += substitution(valueFunction);\n        result += textParts[i + 1];\n      }\n\n      return result;\n    };\n\n    this.varNames = varNames;\n    this.template = template;\n  }\n\n  UriTemplate.prototype = {\n    toString: function toString() {\n      return this.template;\n    },\n    fillFromObject: function fillFromObject(obj) {\n      return this.fill(function (varName) {\n        return obj[varName];\n      });\n    }\n  };\n\n  var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {\n    this.missing = [];\n    this.missingMap = {};\n    this.formatValidators = parent ? Object.create(parent.formatValidators) : {};\n    this.schemas = parent ? Object.create(parent.schemas) : {};\n    this.collectMultiple = collectMultiple;\n    this.errors = [];\n    this.handleError = collectMultiple ? this.collectError : this.returnError;\n\n    if (checkRecursive) {\n      this.checkRecursive = true;\n      this.scanned = [];\n      this.scannedFrozen = [];\n      this.scannedFrozenSchemas = [];\n      this.scannedFrozenValidationErrors = [];\n      this.validatedSchemasKey = 'tv4_validation_id';\n      this.validationErrorsKey = 'tv4_validation_errors_id';\n    }\n\n    if (trackUnknownProperties) {\n      this.trackUnknownProperties = true;\n      this.knownPropertyPaths = {};\n      this.unknownPropertyPaths = {};\n    }\n\n    this.errorReporter = errorReporter || defaultErrorReporter('en');\n\n    if (typeof this.errorReporter === 'string') {\n      throw new Error('debug');\n    }\n\n    this.definedKeywords = {};\n\n    if (parent) {\n      for (var key in parent.definedKeywords) {\n        this.definedKeywords[key] = parent.definedKeywords[key].slice(0);\n      }\n    }\n  };\n\n  ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {\n    this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];\n    this.definedKeywords[keyword].push(keywordFunction);\n  };\n\n  ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {\n    var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);\n    error.message = this.errorReporter(error, data, schema);\n    return error;\n  };\n\n  ValidatorContext.prototype.returnError = function (error) {\n    return error;\n  };\n\n  ValidatorContext.prototype.collectError = function (error) {\n    if (error) {\n      this.errors.push(error);\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {\n    for (var i = startIndex; i < this.errors.length; i++) {\n      this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);\n    }\n\n    return this;\n  };\n\n  ValidatorContext.prototype.banUnknownProperties = function (data, schema) {\n    for (var unknownPath in this.unknownPropertyPaths) {\n      var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {\n        path: unknownPath\n      }, unknownPath, \"\", null, data, schema);\n      var result = this.handleError(error);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.addFormat = function (format, validator) {\n    if (typeof format === 'object') {\n      for (var key in format) {\n        this.addFormat(key, format[key]);\n      }\n\n      return this;\n    }\n\n    this.formatValidators[format] = validator;\n  };\n\n  ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {\n    if (schema['$ref'] !== undefined) {\n      urlHistory = urlHistory || {};\n\n      if (urlHistory[schema['$ref']]) {\n        return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {\n          urls: Object.keys(urlHistory).join(', ')\n        }, '', '', null, undefined, schema);\n      }\n\n      urlHistory[schema['$ref']] = true;\n      schema = this.getSchema(schema['$ref'], urlHistory);\n    }\n\n    return schema;\n  };\n\n  ValidatorContext.prototype.getSchema = function (url, urlHistory) {\n    var schema;\n\n    if (this.schemas[url] !== undefined) {\n      schema = this.schemas[url];\n      return this.resolveRefs(schema, urlHistory);\n    }\n\n    var baseUrl = url;\n    var fragment = \"\";\n\n    if (url.indexOf('#') !== -1) {\n      fragment = url.substring(url.indexOf(\"#\") + 1);\n      baseUrl = url.substring(0, url.indexOf(\"#\"));\n    }\n\n    if (typeof this.schemas[baseUrl] === 'object') {\n      schema = this.schemas[baseUrl];\n      var pointerPath = decodeURIComponent(fragment);\n\n      if (pointerPath === \"\") {\n        return this.resolveRefs(schema, urlHistory);\n      } else if (pointerPath.charAt(0) !== \"/\") {\n        return undefined;\n      }\n\n      var parts = pointerPath.split(\"/\").slice(1);\n\n      for (var i = 0; i < parts.length; i++) {\n        var component = parts[i].replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n\n        if (schema[component] === undefined) {\n          schema = undefined;\n          break;\n        }\n\n        schema = schema[component];\n      }\n\n      if (schema !== undefined) {\n        return this.resolveRefs(schema, urlHistory);\n      }\n    }\n\n    if (this.missing[baseUrl] === undefined) {\n      this.missing.push(baseUrl);\n      this.missing[baseUrl] = baseUrl;\n      this.missingMap[baseUrl] = baseUrl;\n    }\n  };\n\n  ValidatorContext.prototype.searchSchemas = function (schema, url) {\n    if (Array.isArray(schema)) {\n      for (var i = 0; i < schema.length; i++) {\n        this.searchSchemas(schema[i], url);\n      }\n    } else if (schema && typeof schema === \"object\") {\n      if (typeof schema.id === \"string\") {\n        if (isTrustedUrl(url, schema.id)) {\n          if (this.schemas[schema.id] === undefined) {\n            this.schemas[schema.id] = schema;\n          }\n        }\n      }\n\n      for (var key in schema) {\n        if (key !== \"enum\") {\n          if (typeof schema[key] === \"object\") {\n            this.searchSchemas(schema[key], url);\n          } else if (key === \"$ref\") {\n            var uri = getDocumentUri(schema[key]);\n\n            if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {\n              this.missingMap[uri] = uri;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  ValidatorContext.prototype.addSchema = function (url, schema) {\n    //overload\n    if (typeof url !== 'string' || typeof schema === 'undefined') {\n      if (typeof url === 'object' && typeof url.id === 'string') {\n        schema = url;\n        url = schema.id;\n      } else {\n        return;\n      }\n    }\n\n    if (url === getDocumentUri(url) + \"#\") {\n      // Remove empty fragment\n      url = getDocumentUri(url);\n    }\n\n    this.schemas[url] = schema;\n    delete this.missingMap[url];\n    normSchema(schema, url);\n    this.searchSchemas(schema, url);\n  };\n\n  ValidatorContext.prototype.getSchemaMap = function () {\n    var map = {};\n\n    for (var key in this.schemas) {\n      map[key] = this.schemas[key];\n    }\n\n    return map;\n  };\n\n  ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {\n    var list = [];\n\n    for (var key in this.schemas) {\n      if (!filterRegExp || filterRegExp.test(key)) {\n        list.push(key);\n      }\n    }\n\n    return list;\n  };\n\n  ValidatorContext.prototype.getMissingUris = function (filterRegExp) {\n    var list = [];\n\n    for (var key in this.missingMap) {\n      if (!filterRegExp || filterRegExp.test(key)) {\n        list.push(key);\n      }\n    }\n\n    return list;\n  };\n\n  ValidatorContext.prototype.dropSchemas = function () {\n    this.schemas = {};\n    this.reset();\n  };\n\n  ValidatorContext.prototype.reset = function () {\n    this.missing = [];\n    this.missingMap = {};\n    this.errors = [];\n  };\n\n  ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {\n    var topLevel;\n    schema = this.resolveRefs(schema);\n\n    if (!schema) {\n      return null;\n    } else if (schema instanceof ValidationError) {\n      this.errors.push(schema);\n      return schema;\n    }\n\n    var startErrorCount = this.errors.length;\n    var frozenIndex,\n        scannedFrozenSchemaIndex = null,\n        scannedSchemasIndex = null;\n\n    if (this.checkRecursive && data && typeof data === 'object') {\n      topLevel = !this.scanned.length;\n\n      if (data[this.validatedSchemasKey]) {\n        var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);\n\n        if (schemaIndex !== -1) {\n          this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);\n          return null;\n        }\n      }\n\n      if (Object.isFrozen(data)) {\n        frozenIndex = this.scannedFrozen.indexOf(data);\n\n        if (frozenIndex !== -1) {\n          var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);\n\n          if (frozenSchemaIndex !== -1) {\n            this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);\n            return null;\n          }\n        }\n      }\n\n      this.scanned.push(data);\n\n      if (Object.isFrozen(data)) {\n        if (frozenIndex === -1) {\n          frozenIndex = this.scannedFrozen.length;\n          this.scannedFrozen.push(data);\n          this.scannedFrozenSchemas.push([]);\n        }\n\n        scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;\n        this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;\n        this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];\n      } else {\n        if (!data[this.validatedSchemasKey]) {\n          try {\n            Object.defineProperty(data, this.validatedSchemasKey, {\n              value: [],\n              configurable: true\n            });\n            Object.defineProperty(data, this.validationErrorsKey, {\n              value: [],\n              configurable: true\n            });\n          } catch (e) {\n            //IE 7/8 workaround\n            data[this.validatedSchemasKey] = [];\n            data[this.validationErrorsKey] = [];\n          }\n        }\n\n        scannedSchemasIndex = data[this.validatedSchemasKey].length;\n        data[this.validatedSchemasKey][scannedSchemasIndex] = schema;\n        data[this.validationErrorsKey][scannedSchemasIndex] = [];\n      }\n    }\n\n    var errorCount = this.errors.length;\n    var error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateHypermedia(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;\n\n    if (topLevel) {\n      while (this.scanned.length) {\n        var item = this.scanned.pop();\n        delete item[this.validatedSchemasKey];\n      }\n\n      this.scannedFrozen = [];\n      this.scannedFrozenSchemas = [];\n    }\n\n    if (error || errorCount !== this.errors.length) {\n      while (dataPathParts && dataPathParts.length || schemaPathParts && schemaPathParts.length) {\n        var dataPart = dataPathParts && dataPathParts.length ? \"\" + dataPathParts.pop() : null;\n        var schemaPart = schemaPathParts && schemaPathParts.length ? \"\" + schemaPathParts.pop() : null;\n\n        if (error) {\n          error = error.prefixWith(dataPart, schemaPart);\n        }\n\n        this.prefixErrors(errorCount, dataPart, schemaPart);\n      }\n    }\n\n    if (scannedFrozenSchemaIndex !== null) {\n      this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);\n    } else if (scannedSchemasIndex !== null) {\n      data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);\n    }\n\n    return this.handleError(error);\n  };\n\n  ValidatorContext.prototype.validateFormat = function (data, schema) {\n    if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {\n      return null;\n    }\n\n    var errorMessage = this.formatValidators[schema.format].call(null, data, schema);\n\n    if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {\n      return this.createError(ErrorCodes.FORMAT_CUSTOM, {\n        message: errorMessage\n      }, '', '/format', null, data, schema);\n    } else if (errorMessage && typeof errorMessage === 'object') {\n      return this.createError(ErrorCodes.FORMAT_CUSTOM, {\n        message: errorMessage.message || \"?\"\n      }, errorMessage.dataPath || '', errorMessage.schemaPath || \"/format\", null, data, schema);\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {\n    for (var key in this.definedKeywords) {\n      if (typeof schema[key] === 'undefined') {\n        continue;\n      }\n\n      var validationFunctions = this.definedKeywords[key];\n\n      for (var i = 0; i < validationFunctions.length; i++) {\n        var func = validationFunctions[i];\n        var result = func(data, schema[key], schema, dataPointerPath);\n\n        if (typeof result === 'string' || typeof result === 'number') {\n          return this.createError(ErrorCodes.KEYWORD_CUSTOM, {\n            key: key,\n            message: result\n          }, '', '', null, data, schema).prefixWith(null, key);\n        } else if (result && typeof result === 'object') {\n          var code = result.code;\n\n          if (typeof code === 'string') {\n            if (!ErrorCodes[code]) {\n              throw new Error('Undefined error code (use defineError): ' + code);\n            }\n\n            code = ErrorCodes[code];\n          } else if (typeof code !== 'number') {\n            code = ErrorCodes.KEYWORD_CUSTOM;\n          }\n\n          var messageParams = typeof result.message === 'object' ? result.message : {\n            key: key,\n            message: result.message || \"?\"\n          };\n          var schemaPath = result.schemaPath || \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\n          return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);\n        }\n      }\n    }\n\n    return null;\n  };\n\n  function recursiveCompare(A, B) {\n    if (A === B) {\n      return true;\n    }\n\n    if (A && B && typeof A === \"object\" && typeof B === \"object\") {\n      if (Array.isArray(A) !== Array.isArray(B)) {\n        return false;\n      } else if (Array.isArray(A)) {\n        if (A.length !== B.length) {\n          return false;\n        }\n\n        for (var i = 0; i < A.length; i++) {\n          if (!recursiveCompare(A[i], B[i])) {\n            return false;\n          }\n        }\n      } else {\n        var key;\n\n        for (key in A) {\n          if (B[key] === undefined && A[key] !== undefined) {\n            return false;\n          }\n        }\n\n        for (key in B) {\n          if (A[key] === undefined && B[key] !== undefined) {\n            return false;\n          }\n        }\n\n        for (key in A) {\n          if (!recursiveCompare(A[key], B[key])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {\n    var error;\n\n    if (error = this.validateType(data, schema, dataPointerPath)) {\n      return error.prefixWith(null, \"type\");\n    }\n\n    if (error = this.validateEnum(data, schema, dataPointerPath)) {\n      return error.prefixWith(null, \"type\");\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateType = function validateType(data, schema) {\n    if (schema.type === undefined) {\n      return null;\n    }\n\n    var dataType = typeof data;\n\n    if (data === null) {\n      dataType = \"null\";\n    } else if (Array.isArray(data)) {\n      dataType = \"array\";\n    }\n\n    var allowedTypes = schema.type;\n\n    if (!Array.isArray(allowedTypes)) {\n      allowedTypes = [allowedTypes];\n    }\n\n    for (var i = 0; i < allowedTypes.length; i++) {\n      var type = allowedTypes[i];\n\n      if (type === dataType || type === \"integer\" && dataType === \"number\" && data % 1 === 0) {\n        return null;\n      }\n    }\n\n    return this.createError(ErrorCodes.INVALID_TYPE, {\n      type: dataType,\n      expected: allowedTypes.join(\"/\")\n    }, '', '', null, data, schema);\n  };\n\n  ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {\n    if (schema[\"enum\"] === undefined) {\n      return null;\n    }\n\n    for (var i = 0; i < schema[\"enum\"].length; i++) {\n      var enumVal = schema[\"enum\"][i];\n\n      if (recursiveCompare(data, enumVal)) {\n        return null;\n      }\n    }\n\n    return this.createError(ErrorCodes.ENUM_MISMATCH, {\n      value: typeof JSON !== 'undefined' ? JSON.stringify(data) : data\n    }, '', '', null, data, schema);\n  };\n\n  ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {\n    return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || this.validateNaN(data, schema, dataPointerPath) || null;\n  };\n\n  var CLOSE_ENOUGH_LOW = Math.pow(2, -51);\n  var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;\n\n  ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {\n    var multipleOf = schema.multipleOf || schema.divisibleBy;\n\n    if (multipleOf === undefined) {\n      return null;\n    }\n\n    if (typeof data === \"number\") {\n      var remainder = data / multipleOf % 1;\n\n      if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {\n        return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {\n          value: data,\n          multipleOf: multipleOf\n        }, '', '', null, data, schema);\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {\n    if (typeof data !== \"number\") {\n      return null;\n    }\n\n    if (schema.minimum !== undefined) {\n      if (data < schema.minimum) {\n        return this.createError(ErrorCodes.NUMBER_MINIMUM, {\n          value: data,\n          minimum: schema.minimum\n        }, '', '/minimum', null, data, schema);\n      }\n\n      if (schema.exclusiveMinimum && data === schema.minimum) {\n        return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {\n          value: data,\n          minimum: schema.minimum\n        }, '', '/exclusiveMinimum', null, data, schema);\n      }\n    }\n\n    if (schema.maximum !== undefined) {\n      if (data > schema.maximum) {\n        return this.createError(ErrorCodes.NUMBER_MAXIMUM, {\n          value: data,\n          maximum: schema.maximum\n        }, '', '/maximum', null, data, schema);\n      }\n\n      if (schema.exclusiveMaximum && data === schema.maximum) {\n        return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {\n          value: data,\n          maximum: schema.maximum\n        }, '', '/exclusiveMaximum', null, data, schema);\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {\n    if (typeof data !== \"number\") {\n      return null;\n    }\n\n    if (isNaN(data) === true || data === Infinity || data === -Infinity) {\n      return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {\n        value: data\n      }, '', '/type', null, data, schema);\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {\n    return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;\n  };\n\n  ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {\n    if (typeof data !== \"string\") {\n      return null;\n    }\n\n    if (schema.minLength !== undefined) {\n      if (data.length < schema.minLength) {\n        return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {\n          length: data.length,\n          minimum: schema.minLength\n        }, '', '/minLength', null, data, schema);\n      }\n    }\n\n    if (schema.maxLength !== undefined) {\n      if (data.length > schema.maxLength) {\n        return this.createError(ErrorCodes.STRING_LENGTH_LONG, {\n          length: data.length,\n          maximum: schema.maxLength\n        }, '', '/maxLength', null, data, schema);\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {\n    if (typeof data !== \"string\" || typeof schema.pattern !== \"string\" && !(schema.pattern instanceof RegExp)) {\n      return null;\n    }\n\n    var regexp;\n\n    if (schema.pattern instanceof RegExp) {\n      regexp = schema.pattern;\n    } else {\n      var body,\n          flags = ''; // Check for regular expression literals\n      // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5\n\n      var literal = schema.pattern.match(/^\\/(.+)\\/([img]*)$/);\n\n      if (literal) {\n        body = literal[1];\n        flags = literal[2];\n      } else {\n        body = schema.pattern;\n      }\n\n      regexp = new RegExp(body, flags);\n    }\n\n    if (!regexp.test(data)) {\n      return this.createError(ErrorCodes.STRING_PATTERN, {\n        pattern: schema.pattern\n      }, '', '/pattern', null, data, schema);\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {\n    if (!Array.isArray(data)) {\n      return null;\n    }\n\n    return this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null;\n  };\n\n  ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {\n    var error;\n\n    if (schema.minItems !== undefined) {\n      if (data.length < schema.minItems) {\n        error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {\n          length: data.length,\n          minimum: schema.minItems\n        }, '', '/minItems', null, data, schema);\n\n        if (this.handleError(error)) {\n          return error;\n        }\n      }\n    }\n\n    if (schema.maxItems !== undefined) {\n      if (data.length > schema.maxItems) {\n        error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {\n          length: data.length,\n          maximum: schema.maxItems\n        }, '', '/maxItems', null, data, schema);\n\n        if (this.handleError(error)) {\n          return error;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {\n    if (schema.uniqueItems) {\n      for (var i = 0; i < data.length; i++) {\n        for (var j = i + 1; j < data.length; j++) {\n          if (recursiveCompare(data[i], data[j])) {\n            var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {\n              match1: i,\n              match2: j\n            }, '', '/uniqueItems', null, data, schema);\n\n            if (this.handleError(error)) {\n              return error;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {\n    if (schema.items === undefined) {\n      return null;\n    }\n\n    var error, i;\n\n    if (Array.isArray(schema.items)) {\n      for (i = 0; i < data.length; i++) {\n        if (i < schema.items.length) {\n          if (error = this.validateAll(data[i], schema.items[i], [i], [\"items\", i], dataPointerPath + \"/\" + i)) {\n            return error;\n          }\n        } else if (schema.additionalItems !== undefined) {\n          if (typeof schema.additionalItems === \"boolean\") {\n            if (!schema.additionalItems) {\n              error = this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema);\n\n              if (this.handleError(error)) {\n                return error;\n              }\n            }\n          } else if (error = this.validateAll(data[i], schema.additionalItems, [i], [\"additionalItems\"], dataPointerPath + \"/\" + i)) {\n            return error;\n          }\n        }\n      }\n    } else {\n      for (i = 0; i < data.length; i++) {\n        if (error = this.validateAll(data[i], schema.items, [i], [\"items\"], dataPointerPath + \"/\" + i)) {\n          return error;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {\n    if (typeof data !== \"object\" || data === null || Array.isArray(data)) {\n      return null;\n    }\n\n    return this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;\n  };\n\n  ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {\n    var keys = Object.keys(data);\n    var error;\n\n    if (schema.minProperties !== undefined) {\n      if (keys.length < schema.minProperties) {\n        error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {\n          propertyCount: keys.length,\n          minimum: schema.minProperties\n        }, '', '/minProperties', null, data, schema);\n\n        if (this.handleError(error)) {\n          return error;\n        }\n      }\n    }\n\n    if (schema.maxProperties !== undefined) {\n      if (keys.length > schema.maxProperties) {\n        error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {\n          propertyCount: keys.length,\n          maximum: schema.maxProperties\n        }, '', '/maxProperties', null, data, schema);\n\n        if (this.handleError(error)) {\n          return error;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {\n    if (schema.required !== undefined) {\n      for (var i = 0; i < schema.required.length; i++) {\n        var key = schema.required[i];\n\n        if (data[key] === undefined) {\n          var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {\n            key: key\n          }, '', '/required/' + i, null, data, schema);\n\n          if (this.handleError(error)) {\n            return error;\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {\n    var error;\n\n    for (var key in data) {\n      var keyPointerPath = dataPointerPath + \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\n      var foundMatch = false;\n\n      if (schema.properties !== undefined && schema.properties[key] !== undefined) {\n        foundMatch = true;\n\n        if (error = this.validateAll(data[key], schema.properties[key], [key], [\"properties\", key], keyPointerPath)) {\n          return error;\n        }\n      }\n\n      if (schema.patternProperties !== undefined) {\n        for (var patternKey in schema.patternProperties) {\n          var regexp = new RegExp(patternKey);\n\n          if (regexp.test(key)) {\n            foundMatch = true;\n\n            if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], [\"patternProperties\", patternKey], keyPointerPath)) {\n              return error;\n            }\n          }\n        }\n      }\n\n      if (!foundMatch) {\n        if (schema.additionalProperties !== undefined) {\n          if (this.trackUnknownProperties) {\n            this.knownPropertyPaths[keyPointerPath] = true;\n            delete this.unknownPropertyPaths[keyPointerPath];\n          }\n\n          if (typeof schema.additionalProperties === \"boolean\") {\n            if (!schema.additionalProperties) {\n              error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {\n                key: key\n              }, '', '/additionalProperties', null, data, schema).prefixWith(key, null);\n\n              if (this.handleError(error)) {\n                return error;\n              }\n            }\n          } else {\n            if (error = this.validateAll(data[key], schema.additionalProperties, [key], [\"additionalProperties\"], keyPointerPath)) {\n              return error;\n            }\n          }\n        } else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {\n          this.unknownPropertyPaths[keyPointerPath] = true;\n        }\n      } else if (this.trackUnknownProperties) {\n        this.knownPropertyPaths[keyPointerPath] = true;\n        delete this.unknownPropertyPaths[keyPointerPath];\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {\n    var error;\n\n    if (schema.dependencies !== undefined) {\n      for (var depKey in schema.dependencies) {\n        if (data[depKey] !== undefined) {\n          var dep = schema.dependencies[depKey];\n\n          if (typeof dep === \"string\") {\n            if (data[dep] === undefined) {\n              error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {\n                key: depKey,\n                missing: dep\n              }, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n\n              if (this.handleError(error)) {\n                return error;\n              }\n            }\n          } else if (Array.isArray(dep)) {\n            for (var i = 0; i < dep.length; i++) {\n              var requiredKey = dep[i];\n\n              if (data[requiredKey] === undefined) {\n                error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {\n                  key: depKey,\n                  missing: requiredKey\n                }, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n\n                if (this.handleError(error)) {\n                  return error;\n                }\n              }\n            }\n          } else {\n            if (error = this.validateAll(data, dep, [], [\"dependencies\", depKey], dataPointerPath)) {\n              return error;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {\n    return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;\n  };\n\n  ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {\n    if (schema.allOf === undefined) {\n      return null;\n    }\n\n    var error;\n\n    for (var i = 0; i < schema.allOf.length; i++) {\n      var subSchema = schema.allOf[i];\n\n      if (error = this.validateAll(data, subSchema, [], [\"allOf\", i], dataPointerPath)) {\n        return error;\n      }\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {\n    if (schema.anyOf === undefined) {\n      return null;\n    }\n\n    var errors = [];\n    var startErrorCount = this.errors.length;\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\n    if (this.trackUnknownProperties) {\n      oldUnknownPropertyPaths = this.unknownPropertyPaths;\n      oldKnownPropertyPaths = this.knownPropertyPaths;\n    }\n\n    var errorAtEnd = true;\n\n    for (var i = 0; i < schema.anyOf.length; i++) {\n      if (this.trackUnknownProperties) {\n        this.unknownPropertyPaths = {};\n        this.knownPropertyPaths = {};\n      }\n\n      var subSchema = schema.anyOf[i];\n      var errorCount = this.errors.length;\n      var error = this.validateAll(data, subSchema, [], [\"anyOf\", i], dataPointerPath);\n\n      if (error === null && errorCount === this.errors.length) {\n        this.errors = this.errors.slice(0, startErrorCount);\n\n        if (this.trackUnknownProperties) {\n          for (var knownKey in this.knownPropertyPaths) {\n            oldKnownPropertyPaths[knownKey] = true;\n            delete oldUnknownPropertyPaths[knownKey];\n          }\n\n          for (var unknownKey in this.unknownPropertyPaths) {\n            if (!oldKnownPropertyPaths[unknownKey]) {\n              oldUnknownPropertyPaths[unknownKey] = true;\n            }\n          } // We need to continue looping so we catch all the property definitions, but we don't want to return an error\n\n\n          errorAtEnd = false;\n          continue;\n        }\n\n        return null;\n      }\n\n      if (error) {\n        errors.push(error.prefixWith(null, \"\" + i).prefixWith(null, \"anyOf\"));\n      }\n    }\n\n    if (this.trackUnknownProperties) {\n      this.unknownPropertyPaths = oldUnknownPropertyPaths;\n      this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n\n    if (errorAtEnd) {\n      errors = errors.concat(this.errors.slice(startErrorCount));\n      this.errors = this.errors.slice(0, startErrorCount);\n      return this.createError(ErrorCodes.ANY_OF_MISSING, {}, \"\", \"/anyOf\", errors, data, schema);\n    }\n  };\n\n  ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {\n    if (schema.oneOf === undefined) {\n      return null;\n    }\n\n    var validIndex = null;\n    var errors = [];\n    var startErrorCount = this.errors.length;\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\n    if (this.trackUnknownProperties) {\n      oldUnknownPropertyPaths = this.unknownPropertyPaths;\n      oldKnownPropertyPaths = this.knownPropertyPaths;\n    }\n\n    for (var i = 0; i < schema.oneOf.length; i++) {\n      if (this.trackUnknownProperties) {\n        this.unknownPropertyPaths = {};\n        this.knownPropertyPaths = {};\n      }\n\n      var subSchema = schema.oneOf[i];\n      var errorCount = this.errors.length;\n      var error = this.validateAll(data, subSchema, [], [\"oneOf\", i], dataPointerPath);\n\n      if (error === null && errorCount === this.errors.length) {\n        if (validIndex === null) {\n          validIndex = i;\n        } else {\n          this.errors = this.errors.slice(0, startErrorCount);\n          return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {\n            index1: validIndex,\n            index2: i\n          }, \"\", \"/oneOf\", null, data, schema);\n        }\n\n        if (this.trackUnknownProperties) {\n          for (var knownKey in this.knownPropertyPaths) {\n            oldKnownPropertyPaths[knownKey] = true;\n            delete oldUnknownPropertyPaths[knownKey];\n          }\n\n          for (var unknownKey in this.unknownPropertyPaths) {\n            if (!oldKnownPropertyPaths[unknownKey]) {\n              oldUnknownPropertyPaths[unknownKey] = true;\n            }\n          }\n        }\n      } else if (error) {\n        errors.push(error);\n      }\n    }\n\n    if (this.trackUnknownProperties) {\n      this.unknownPropertyPaths = oldUnknownPropertyPaths;\n      this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n\n    if (validIndex === null) {\n      errors = errors.concat(this.errors.slice(startErrorCount));\n      this.errors = this.errors.slice(0, startErrorCount);\n      return this.createError(ErrorCodes.ONE_OF_MISSING, {}, \"\", \"/oneOf\", errors, data, schema);\n    } else {\n      this.errors = this.errors.slice(0, startErrorCount);\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {\n    if (schema.not === undefined) {\n      return null;\n    }\n\n    var oldErrorCount = this.errors.length;\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\n    if (this.trackUnknownProperties) {\n      oldUnknownPropertyPaths = this.unknownPropertyPaths;\n      oldKnownPropertyPaths = this.knownPropertyPaths;\n      this.unknownPropertyPaths = {};\n      this.knownPropertyPaths = {};\n    }\n\n    var error = this.validateAll(data, schema.not, null, null, dataPointerPath);\n    var notErrors = this.errors.slice(oldErrorCount);\n    this.errors = this.errors.slice(0, oldErrorCount);\n\n    if (this.trackUnknownProperties) {\n      this.unknownPropertyPaths = oldUnknownPropertyPaths;\n      this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n\n    if (error === null && notErrors.length === 0) {\n      return this.createError(ErrorCodes.NOT_PASSED, {}, \"\", \"/not\", null, data, schema);\n    }\n\n    return null;\n  };\n\n  ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {\n    if (!schema.links) {\n      return null;\n    }\n\n    var error;\n\n    for (var i = 0; i < schema.links.length; i++) {\n      var ldo = schema.links[i];\n\n      if (ldo.rel === \"describedby\") {\n        var template = new UriTemplate(ldo.href);\n        var allPresent = true;\n\n        for (var j = 0; j < template.varNames.length; j++) {\n          if (!(template.varNames[j] in data)) {\n            allPresent = false;\n            break;\n          }\n        }\n\n        if (allPresent) {\n          var schemaUrl = template.fillFromObject(data);\n          var subSchema = {\n            \"$ref\": schemaUrl\n          };\n\n          if (error = this.validateAll(data, subSchema, [], [\"links\", i], dataPointerPath)) {\n            return error;\n          }\n        }\n      }\n    }\n  }; // parseURI() and resolveUrl() are from https://gist.github.com/1088850\n  //   -  released as public domain by author (\"Yaffle\") - see comments on gist\n\n\n  function parseURI(url) {\n    var m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/); // authority = '//' + user + ':' + pass '@' + hostname + ':' port\n\n    return m ? {\n      href: m[0] || '',\n      protocol: m[1] || '',\n      authority: m[2] || '',\n      host: m[3] || '',\n      hostname: m[4] || '',\n      port: m[5] || '',\n      pathname: m[6] || '',\n      search: m[7] || '',\n      hash: m[8] || ''\n    } : null;\n  }\n\n  function resolveUrl(base, href) {\n    // RFC 3986\n    function removeDotSegments(input) {\n      var output = [];\n      input.replace(/^(\\.\\.?(\\/|$))+/, '').replace(/\\/(\\.(\\/|$))+/g, '/').replace(/\\/\\.\\.$/, '/../').replace(/\\/?[^\\/]*/g, function (p) {\n        if (p === '/..') {\n          output.pop();\n        } else {\n          output.push(p);\n        }\n      });\n      return output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\n    }\n\n    href = parseURI(href || '');\n    base = parseURI(base || '');\n    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;\n  }\n\n  function getDocumentUri(uri) {\n    return uri.split('#')[0];\n  }\n\n  function normSchema(schema, baseUri) {\n    if (schema && typeof schema === \"object\") {\n      if (baseUri === undefined) {\n        baseUri = schema.id;\n      } else if (typeof schema.id === \"string\") {\n        baseUri = resolveUrl(baseUri, schema.id);\n        schema.id = baseUri;\n      }\n\n      if (Array.isArray(schema)) {\n        for (var i = 0; i < schema.length; i++) {\n          normSchema(schema[i], baseUri);\n        }\n      } else {\n        if (typeof schema['$ref'] === \"string\") {\n          schema['$ref'] = resolveUrl(baseUri, schema['$ref']);\n        }\n\n        for (var key in schema) {\n          if (key !== \"enum\") {\n            normSchema(schema[key], baseUri);\n          }\n        }\n      }\n    }\n  }\n\n  function defaultErrorReporter(language) {\n    language = language || 'en';\n    var errorMessages = languages[language];\n    return function (error) {\n      var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];\n\n      if (typeof messageTemplate !== 'string') {\n        return \"Unknown error code \" + error.code + \": \" + JSON.stringify(error.messageParams);\n      }\n\n      var messageParams = error.params; // Adapted from Crockford's supplant()\n\n      return messageTemplate.replace(/\\{([^{}]*)\\}/g, function (whole, varName) {\n        var subValue = messageParams[varName];\n        return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;\n      });\n    };\n  }\n\n  var ErrorCodes = {\n    INVALID_TYPE: 0,\n    ENUM_MISMATCH: 1,\n    ANY_OF_MISSING: 10,\n    ONE_OF_MISSING: 11,\n    ONE_OF_MULTIPLE: 12,\n    NOT_PASSED: 13,\n    // Numeric errors\n    NUMBER_MULTIPLE_OF: 100,\n    NUMBER_MINIMUM: 101,\n    NUMBER_MINIMUM_EXCLUSIVE: 102,\n    NUMBER_MAXIMUM: 103,\n    NUMBER_MAXIMUM_EXCLUSIVE: 104,\n    NUMBER_NOT_A_NUMBER: 105,\n    // String errors\n    STRING_LENGTH_SHORT: 200,\n    STRING_LENGTH_LONG: 201,\n    STRING_PATTERN: 202,\n    // Object errors\n    OBJECT_PROPERTIES_MINIMUM: 300,\n    OBJECT_PROPERTIES_MAXIMUM: 301,\n    OBJECT_REQUIRED: 302,\n    OBJECT_ADDITIONAL_PROPERTIES: 303,\n    OBJECT_DEPENDENCY_KEY: 304,\n    // Array errors\n    ARRAY_LENGTH_SHORT: 400,\n    ARRAY_LENGTH_LONG: 401,\n    ARRAY_UNIQUE: 402,\n    ARRAY_ADDITIONAL_ITEMS: 403,\n    // Custom/user-defined errors\n    FORMAT_CUSTOM: 500,\n    KEYWORD_CUSTOM: 501,\n    // Schema structure\n    CIRCULAR_REFERENCE: 600,\n    // Non-standard validation options\n    UNKNOWN_PROPERTY: 1000\n  };\n  var ErrorCodeLookup = {};\n\n  for (var key in ErrorCodes) {\n    ErrorCodeLookup[ErrorCodes[key]] = key;\n  }\n\n  var ErrorMessagesDefault = {\n    INVALID_TYPE: \"Invalid type: {type} (expected {expected})\",\n    ENUM_MISMATCH: \"No enum match for: {value}\",\n    ANY_OF_MISSING: \"Data does not match any schemas from \\\"anyOf\\\"\",\n    ONE_OF_MISSING: \"Data does not match any schemas from \\\"oneOf\\\"\",\n    ONE_OF_MULTIPLE: \"Data is valid against more than one schema from \\\"oneOf\\\": indices {index1} and {index2}\",\n    NOT_PASSED: \"Data matches schema from \\\"not\\\"\",\n    // Numeric errors\n    NUMBER_MULTIPLE_OF: \"Value {value} is not a multiple of {multipleOf}\",\n    NUMBER_MINIMUM: \"Value {value} is less than minimum {minimum}\",\n    NUMBER_MINIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive minimum {minimum}\",\n    NUMBER_MAXIMUM: \"Value {value} is greater than maximum {maximum}\",\n    NUMBER_MAXIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive maximum {maximum}\",\n    NUMBER_NOT_A_NUMBER: \"Value {value} is not a valid number\",\n    // String errors\n    STRING_LENGTH_SHORT: \"String is too short ({length} chars), minimum {minimum}\",\n    STRING_LENGTH_LONG: \"String is too long ({length} chars), maximum {maximum}\",\n    STRING_PATTERN: \"String does not match pattern: {pattern}\",\n    // Object errors\n    OBJECT_PROPERTIES_MINIMUM: \"Too few properties defined ({propertyCount}), minimum {minimum}\",\n    OBJECT_PROPERTIES_MAXIMUM: \"Too many properties defined ({propertyCount}), maximum {maximum}\",\n    OBJECT_REQUIRED: \"Missing required property: {key}\",\n    OBJECT_ADDITIONAL_PROPERTIES: \"Additional properties not allowed\",\n    OBJECT_DEPENDENCY_KEY: \"Dependency failed - key must exist: {missing} (due to key: {key})\",\n    // Array errors\n    ARRAY_LENGTH_SHORT: \"Array is too short ({length}), minimum {minimum}\",\n    ARRAY_LENGTH_LONG: \"Array is too long ({length}), maximum {maximum}\",\n    ARRAY_UNIQUE: \"Array items are not unique (indices {match1} and {match2})\",\n    ARRAY_ADDITIONAL_ITEMS: \"Additional items not allowed\",\n    // Format errors\n    FORMAT_CUSTOM: \"Format validation failed ({message})\",\n    KEYWORD_CUSTOM: \"Keyword failed: {key} ({message})\",\n    // Schema structure\n    CIRCULAR_REFERENCE: \"Circular $refs: {urls}\",\n    // Non-standard validation options\n    UNKNOWN_PROPERTY: \"Unknown property (not in schema)\"\n  };\n\n  function ValidationError(code, params, dataPath, schemaPath, subErrors) {\n    Error.call(this);\n\n    if (code === undefined) {\n      throw new Error(\"No error code supplied: \" + schemaPath);\n    }\n\n    this.message = '';\n    this.params = params;\n    this.code = code;\n    this.dataPath = dataPath || \"\";\n    this.schemaPath = schemaPath || \"\";\n    this.subErrors = subErrors || null;\n    var err = new Error(this.message);\n    this.stack = err.stack || err.stacktrace;\n\n    if (!this.stack) {\n      try {\n        throw err;\n      } catch (err) {\n        this.stack = err.stack || err.stacktrace;\n      }\n    }\n  }\n\n  ValidationError.prototype = Object.create(Error.prototype);\n  ValidationError.prototype.constructor = ValidationError;\n  ValidationError.prototype.name = 'ValidationError';\n\n  ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {\n    if (dataPrefix !== null) {\n      dataPrefix = dataPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n      this.dataPath = \"/\" + dataPrefix + this.dataPath;\n    }\n\n    if (schemaPrefix !== null) {\n      schemaPrefix = schemaPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n      this.schemaPath = \"/\" + schemaPrefix + this.schemaPath;\n    }\n\n    if (this.subErrors !== null) {\n      for (var i = 0; i < this.subErrors.length; i++) {\n        this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);\n      }\n    }\n\n    return this;\n  };\n\n  function isTrustedUrl(baseUrl, testUrl) {\n    if (testUrl.substring(0, baseUrl.length) === baseUrl) {\n      var remainder = testUrl.substring(baseUrl.length);\n\n      if (testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === \"/\" || remainder.charAt(0) === \"#\" || remainder.charAt(0) === \"?\") {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var languages = {};\n\n  function createApi(language) {\n    var globalContext = new ValidatorContext();\n    var currentLanguage;\n    var customErrorReporter;\n    var api = {\n      setErrorReporter: function setErrorReporter(reporter) {\n        if (typeof reporter === 'string') {\n          return this.language(reporter);\n        }\n\n        customErrorReporter = reporter;\n        return true;\n      },\n      addFormat: function addFormat() {\n        globalContext.addFormat.apply(globalContext, arguments);\n      },\n      language: function language(code) {\n        if (!code) {\n          return currentLanguage;\n        }\n\n        if (!languages[code]) {\n          code = code.split('-')[0]; // fall back to base language\n        }\n\n        if (languages[code]) {\n          currentLanguage = code;\n          return code; // so you can tell if fall-back has happened\n        }\n\n        return false;\n      },\n      addLanguage: function addLanguage(code, messageMap) {\n        var key;\n\n        for (key in ErrorCodes) {\n          if (messageMap[key] && !messageMap[ErrorCodes[key]]) {\n            messageMap[ErrorCodes[key]] = messageMap[key];\n          }\n        }\n\n        var rootCode = code.split('-')[0];\n\n        if (!languages[rootCode]) {\n          // use for base language if not yet defined\n          languages[code] = messageMap;\n          languages[rootCode] = messageMap;\n        } else {\n          languages[code] = Object.create(languages[rootCode]);\n\n          for (key in messageMap) {\n            if (typeof languages[rootCode][key] === 'undefined') {\n              languages[rootCode][key] = messageMap[key];\n            }\n\n            languages[code][key] = messageMap[key];\n          }\n        }\n\n        return this;\n      },\n      freshApi: function freshApi(language) {\n        var result = createApi();\n\n        if (language) {\n          result.language(language);\n        }\n\n        return result;\n      },\n      validate: function validate(data, schema, checkRecursive, banUnknownProperties) {\n        var def = defaultErrorReporter(currentLanguage);\n        var errorReporter = customErrorReporter ? function (error, data, schema) {\n          return customErrorReporter(error, data, schema) || def(error, data, schema);\n        } : def;\n        var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);\n\n        if (typeof schema === \"string\") {\n          schema = {\n            \"$ref\": schema\n          };\n        }\n\n        context.addSchema(\"\", schema);\n        var error = context.validateAll(data, schema, null, null, \"\");\n\n        if (!error && banUnknownProperties) {\n          error = context.banUnknownProperties(data, schema);\n        }\n\n        this.error = error;\n        this.missing = context.missing;\n        this.valid = error === null;\n        return this.valid;\n      },\n      validateResult: function validateResult() {\n        var result = {\n          toString: function toString() {\n            return this.valid ? 'valid' : this.error.message;\n          }\n        };\n        this.validate.apply(result, arguments);\n        return result;\n      },\n      validateMultiple: function validateMultiple(data, schema, checkRecursive, banUnknownProperties) {\n        var def = defaultErrorReporter(currentLanguage);\n        var errorReporter = customErrorReporter ? function (error, data, schema) {\n          return customErrorReporter(error, data, schema) || def(error, data, schema);\n        } : def;\n        var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);\n\n        if (typeof schema === \"string\") {\n          schema = {\n            \"$ref\": schema\n          };\n        }\n\n        context.addSchema(\"\", schema);\n        context.validateAll(data, schema, null, null, \"\");\n\n        if (banUnknownProperties) {\n          context.banUnknownProperties(data, schema);\n        }\n\n        var result = {\n          toString: function toString() {\n            return this.valid ? 'valid' : this.error.message;\n          }\n        };\n        result.errors = context.errors;\n        result.missing = context.missing;\n        result.valid = result.errors.length === 0;\n        return result;\n      },\n      addSchema: function addSchema() {\n        return globalContext.addSchema.apply(globalContext, arguments);\n      },\n      getSchema: function getSchema() {\n        return globalContext.getSchema.apply(globalContext, arguments);\n      },\n      getSchemaMap: function getSchemaMap() {\n        return globalContext.getSchemaMap.apply(globalContext, arguments);\n      },\n      getSchemaUris: function getSchemaUris() {\n        return globalContext.getSchemaUris.apply(globalContext, arguments);\n      },\n      getMissingUris: function getMissingUris() {\n        return globalContext.getMissingUris.apply(globalContext, arguments);\n      },\n      dropSchemas: function dropSchemas() {\n        globalContext.dropSchemas.apply(globalContext, arguments);\n      },\n      defineKeyword: function defineKeyword() {\n        globalContext.defineKeyword.apply(globalContext, arguments);\n      },\n      defineError: function defineError(codeName, codeNumber, defaultMessage) {\n        if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {\n          throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');\n        }\n\n        if (typeof codeNumber !== 'number' || codeNumber % 1 !== 0 || codeNumber < 10000) {\n          throw new Error('Code number must be an integer > 10000');\n        }\n\n        if (typeof ErrorCodes[codeName] !== 'undefined') {\n          throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);\n        }\n\n        if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {\n          throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);\n        }\n\n        ErrorCodes[codeName] = codeNumber;\n        ErrorCodeLookup[codeNumber] = codeName;\n        ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;\n\n        for (var langCode in languages) {\n          var language = languages[langCode];\n\n          if (language[codeName]) {\n            language[codeNumber] = language[codeNumber] || language[codeName];\n          }\n        }\n      },\n      reset: function reset() {\n        globalContext.reset();\n        this.error = null;\n        this.missing = [];\n        this.valid = true;\n      },\n      missing: [],\n      error: null,\n      valid: true,\n      normSchema: normSchema,\n      resolveUrl: resolveUrl,\n      getDocumentUri: getDocumentUri,\n      errorCodes: ErrorCodes\n    };\n    api.language(language || 'en');\n    return api;\n  }\n\n  var tv4 = createApi();\n  tv4.addLanguage('en-gb', ErrorMessagesDefault); //legacy property\n\n  tv4.tv4 = tv4;\n  return tv4; // used by _header.js to globalise.\n});","map":null,"metadata":{},"sourceType":"script"}